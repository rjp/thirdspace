In this doc: MID is a message ID, USER is a username, FOLDER is a foldername, S1 is a subscribed folder

# Counters

    s:message       Message ID sequence counter
    s:thread        Thread ID sequence counter

# Folders

    folder:FOLDER   set of all the message IDs in this folder

# Messages

    message:MID     redis hash of the message headers + json version of such
    body:MID        the body of message MID as a plain redis key/value

Storing messages as hashes rather than JSON is sensible - removes a lot of parsing and lets us do sorting inside redis rather than fetching all messages, parsing each one, then sorting, then turning them back into JSON. redis can sort a list or set by reference to a related hash field. To get a sorted list of the messages in folder F, 
    
    SORT folder:F BY message:*->epoch # by time
    SORT folder:F BY message:*->thread # by thread
    SORT folder:F BY message:*->from # by poster

If we store a JSON representation of the message headers in a hash field, we can retrieve that in sorted order,

    SORT folder:F BY message:*->epoch GET message:*->json # headers from folder by time

This probably obviates the need for ZSET folders mentioned below. Multiple BY clauses would be nice to allow sorting by thread id, then epoch in order to group messages in a gmail-style fashion but is not currently supported in redis.

# Users

    user:USER       user profile stored as a hash
    user:USER:read  set of message IDs the user has read
    user:USER:subs  set of subscribed foldernames
    user:USER:all   set of all subscribed messages USER can see

user:USER:all is dynamically generated by the following sequence,

    SMEMBERS user:USER:subs
    # convert to "folder:C1 folder:C2 ..." => $list_of_folders
    SUNIONSTORE user:USER:all $list_of_folders
    SDIFF user:USER:all user:USER:read
